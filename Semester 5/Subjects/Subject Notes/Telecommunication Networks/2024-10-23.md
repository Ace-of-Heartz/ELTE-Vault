---
is_lecture: true
course:
---

# Hálózati réteg

## Forgalomirányító algoritmusok

**Def.**: *Hálózati réteg* szoftverének azon része, amely azért a döntésért felelős, hogy a bejövő csomag melyik kimeneti vonalon kerüljön továbbításra

**Két lépés**:
1. Forgalomirányító táblázatok feltöltése, karbantartása
2. Továbbítás

**Elvárások**:
- helyesség
- egyszerűség
- robosztusság
- stabilitás
- igazságosság
- optimalitás
- hatékonyság

**Algoritmus osztályok**:
1. *Adaptív algoritmusok*: A topológia és rendszerint a forgalom befolyásolhatja a döntést 
	- **Különbségek** az egyes adaptív algoritmusokban:
		- **Információ forrása**: szomszédok, helyileg, minden router
		- **Útvonalak megváltoztatásának ideje**: meghatározott másodperc, terhelés változásra, topológia változásra
		- **Optimalizáláshoz használt mérték**: távolság, ugrások (*hops*) száma, becsült késleltetés
2. *Nem-adaptív algoritmusok*: Offline meghatározás, betöltés a router-ekbe induláskor


### Optimalitási elv

Ha $J$ router az $I$ routertől $K$ router felé vezető *optimális útvonalon* helyezkedik el, akkor a $J$-től $K$-ig vezető útvonal ugyanerre esik

**Következmény**:
- Összes forrásból egy célba tartó optimális utak egy olyan fát alkotnak, amelynek a gyökere a cél
- Ez az ú.n. **nyelőfa**

### Legrövidebb út alapú forgalomirányítás

#### Alhálózat repr.

Tekinthető egy **gráfnak**:
- Minden *router* egy csomópont
- Minden él egy *kommunikációs vonalnak* (*link*) felel meg
- Éleken értelmezzük $w:E\to \mathbb{R}_{0}^+$ nem-negatív súlyfv.-t ~ **Legrövidebb utak** meghatározásához használjunk
	- $G=(V,E)$ gráf reprezentálja az alhálózatot
	- $P$ útvonal súlya: $w(P) = \sum_{e\in P}w(e)$ 

### Dinamikus algoritmusok

**Dinamikus algoritmusok** csoportjai:
1. Távolságvektor alapú (*distance vector routing*)
2. Kapcsolatállapot alapú (*link-state routing*)

#### Távolságvektor alapú forgalomirányítás

Minden *router*-nek egy táblázatot kell karbantartania, amelyben minden célhoz szerepel:
- legrövidebb ismert távolság
- annak a vonalnak azonosítója, amelyiken a célhoz lehet eljutni

Táblázatokat a *szomszédoktól* származó információk alapján frissítik.
- **Elosztott Bellman-Ford forgalomirányítási algoritmus**ként is nevezik
- *ARPANET* eredeti forgalomirányító algoritmusa volt (*RIP* ~ *Routing Information Protocol*)

##### Eloszott Bellman-Ford algo.

**Környezet és működés**: 
- Minden csomópont csak a közvetlen *szomszédjaival* kommunikálható
- *Aszinkron működés*
- Minden állomásnak van saját *távolság vektora*. Periodikusan elküldi a direkt szomszédoknak.
- Kapott távolság vektorok alapján minden csomópont új táblázatot állít elő.
	- Ismertlen célállomások kötlsége $\infty$

##### Végtelenségig számolás problémája

**Probléma**:
- "jó hír" gyorsan terjed
- "rossz hír" lassan terjed
- Azaz: ciklusok keletkezhetnek
- Lehetséges megoldás:
	- *split horizon with poisoned reverse*
	- negatív információt küld vissza arról a szomszédjának, amit tőleg "tanult"

##### Split Horizon with Poisoned Reverse

1. Ha a $C$ $B$-n keresztül irányítja a forgalmat az $A$ állomáshoz
	1. $C$ állomás $B$-nek ($D(C,A) = \infty$) távolságot küld
	2. $B$ állomás nem fog $C$-n keresztül irányítani az $A$-ba menő forgalmat


#### Kapcsolatállapot alapú forgalomirányítás (Link-state routing)

**Motiváció**:
- Eltérő sávszélek figyelembevétele
- Távolság alapú algok lassan konvergálnak

**Alapötlet 5 lépésből**:
1. Szomszédok felkutatása, hálózati címek meghatározása
2. Késleltetés vagy költség megmérése minden szomszédhoz
3. Egy csomag összeállítása a megismert információkból
4. Csomag elküldése az *összes többi* routernek
5. Kiszámítani a legrövidebb utata az összes többi routerhez
	1. **Dijkstra algoritmusa**


**Működése**:
1. Speciális *HELLO* csomag elküldésével szomszédok megismerése.
	1. Minden kimenő vonalán kiküld
	2. **Elvárás**: a vonal másik végén lévő router választ adjon, amelyben az azonosítóját közli (*globálisan egyedi*)
2. Speciális *ECHO* csomag küldésével, amelyet a másik oldalnak azonnal visszakell küldenie
	1. Körbeérési idő felével becsülhető a késleltetés
	2. **Javítás**: többszöri kísérlet átlagából számított érték
3. Adatok összegzése, csomag előállítása megismert infókból.
	1. **Kapcsolatállapot tartalma**: 
		1. Feladó azonosítója
		2. Sorszám
		3. Korérték
		4. Szomszédok listája
	2. Minden szomszédhoz megadják a felé tapasztalható késést
	3. Előállítás történhet periodikusan vagy hiba esemény esetén (U.n. *LSA* ~ *Link State Advertisment* ~ kapcsolatállapot hirdetés)
4. Kapcsolat csomagok megbízható szétosztása
	1. **Használható**: *elárasztás módszere*
	2. Csomagban van egy sorszám, amely minden küldésnél 1-el nő
	3. Routerek számon tartanak minden (*forrás*,*sorszám*) párt, amelyet látnak
	4. Ha új pár érkezik, azt küldik minden vonalon, kivéve azon, amin érkezett
	5. Másod példányokat eldobják
	6. Kisebb sorszámúakat elavultnak tekintik, nem küldik tovább


| Probléma                           | Megoldás                                                                                                     |
| ---------------------------------- | ------------------------------------------------------------------------------------------------------------ |
| Sorszámok egy idő után körbe érnek | 32 bites sorszám használata                                                                                  |
| Router összeomlik                  | Kor bevezetése. Kor értéket másodpercenként csökkenti a router, ha a kor eléri a nullát, akkor el kell dobni |
| Sorszám mező megsérül              | Lásd egyel feljebb.                                                                                          |

**További finomítások**:
- tároló területre kerül először a csomag és a nem küldési sorba
- nyugtázás

1. **Új útvonalak számítása**:
	1. Amint egy *router* a kapcsolatállapot csomagok egy teljes készletét összegyüjtötte, megszerkesztheti az alhálózat teljes gráfját, *mivel minden kapcsolat képviselve van*.
	2. Erre lefuttatható *Dijkstra-algoritmusa*: eredménye a forgalomirányító tábla

**Jellemzők**:
- *Router*-ek és *router*-ek szomszédainak átlagos számával arányos tárterület kell az algoritmus futtatásához $O(kn)$:
	- $k$ ~ szomszédok száma
	- $n$ ~ *router*-ek száma
- Nagy hálózatok esetén a számítás költséges és memória igényes lesz!
- Hardver és szoftver problémák komoly gondot okozhatnak!
- Hálózat méretének növekedésével a hiba valószínűsége nő!

##### Dijstra algoritmus (1959)

Statikus algoritmus
**Cél**: két csomópont közötti legrövidebb út meghatározása

**Informális leírás**:
- Minden csomópont felcímkézünk a forrás csomóponttól való legrövidebb ismert út mentén mért távolsággal
- **Kezdetben**: 
	- minden távolság $\infty$
	- minden címke *ideiglenes*
- Algoritmus működése során:
	- Címkék megváltozhatnak az utak megtalálásával
	- Két fajta címke: 
		- *ideiglenes*
		- *állandó*
	- Legrövidebb út megtalálásával a címke állandó címkévé válik, továbbá nem változik

#### OSPF vs. IS-IS

Két eltérő implementáció a link-state routing stratégiáknak

**OSPF**:
- cégek és adatközpontok
- több lehetőséget támogat
- IPv4 felett:
	- LSA-k IPv4 feletti küldése
	- OSPFv3 szükséges IPv6-hoz
- **Felépítés**:
	- átfedő területek köré szerveződik
	- *Area 0* ~ hálózat magja

**IS-IS**:
- Internet szolgáltatók által használt
- Sokkal tömörebb
	- Kisebb hálózati overhead
	- Több eszközt támogat
- Nem kötődik IP-hez
	- IPv4 és IPv6-al is működik
- **Felépítés**:
	- 2-szintű hierarchia
	- 2. szint gerinchálózat

## Szállítási réteg felé nyújtott szolgálatok

**Vezérelvek**:
1. Szolgálat legyen független az alhálózat kialakításától
2. A szállítási réteg felé el kell takarnai a jelenlevő alhálózatok *számát*, *típusát*, *topológiáját*
3. Szállítási réteg számára rendelkezésre bocsájtott hálózati címeknek egységes számozási rendszert kell alkotnikuk (LAN és WAN esetén is)
 
**Szolgálatok két fajtáját különböztetik meg**:
1. Összeköttetés nélküli hálózat (*Internet*)
	1. Datagram alhálózat
2. Összeköttetés alapú szolgálat (*ATM*)
	1. Virtuális áramkör alhálózat